module Primes = struct

    type t = { prime: int; multiple: int }
    
    val make : int -> t
    let make n = { prime = n; multiple = n }
    
    val release : t -> unit
    let release t =
        free t
    
    val private next : t * int -> t * bool
    let next t n =
        let { t; ~prime; ~multiple } = t in
        if multiple < n then
            next { t with prime = prime; multiple = (multiple + prime) } n
        else
            { t with ~prime; ~multiple }, n = multiple

    val private make_buffer : unit -> t Buffer.t
    let make_buffer () =
        Buffer.make make release (64 * 1024)               (* resizing the buffer segfaults *)
    
    val private next_buffer : t Buffer.t * int -> t Buffer.t * bool
    let next_buffer buffer n = 
        let { buffer; Buffer.buf = buf; Buffer.last = last } = buffer in
        let buf, divisible = next_loop buf n false 0 last in
        let buffer = { buffer with Buffer.buf = buf; Buffer.last = last } in
        if divisible then
            buffer, false
        else
            let next_t = make n in
            Buffer.add buffer next_t, true
    
    val private next_loop : t Array.t * int * bool * int * int -> t Array.t * bool
    let next_loop t n divisible index last =
        if index < last then
            let dummy = make 0 in
            let t, item = Array.swap t index dummy in
            let item, ndiv = next item n in
            let t, dummy = Array.swap t index item in
            let () = release dummy in
            next_loop t n (ndiv || divisible) (index + 1) last
        else
            t, divisible
    
    val private iterate : int * (int * 'a -> 'a ) * 'a -> 'a
    let iterate limit f acc =
        let buf = make_buffer () in
        iterate_loop buf f acc 3 limit
    
    val private iterate_loop : t Buffer.t * (int * 'a -> 'a) * 'a * int * int -> 'a
    let iterate_loop buffer f acc pprime limit =
        if pprime <= limit then
            let buffer, is_prime = next_buffer buffer pprime in
            if is_prime then
                iterate_loop buffer f (f pprime acc) (pprime + 2) limit
            else
                iterate_loop buffer f acc (pprime + 2) limit
        else
            let () = Buffer.release buffer in
            acc
    
    val for_prime_to : int * (int * 'a -> 'a ) * 'a -> 'a
    let for_prime_to limit f acc =
        if limit >= 2 then
            let acc = f 2 acc in
            iterate limit f acc
        else
            acc
    
    val while_ : (int * 'a obs -> bool) * (int * 'a -> 'a) * 'a -> 'a
    let while_ testf accf acc =
        if testf 2 !acc then
            let acc = accf 2 acc in
            if testf 3 !acc then
                let acc = accf 3 acc in
                if testf 5 !acc then
                    let acc = accf 5 acc in
                    let buffer = make_buffer () in
                    let buffer = Buffer.add buffer (make 3) in
                    let buffer = Buffer.add buffer (make 5) in
                    while_skip2 buffer 7 testf accf acc
                else
                    acc
            else
                acc
        else
            acc
        
    
    val private while_skip2 : t Buffer.t * int * (int * 'a obs -> bool) * (int * 'a -> 'a) * 'a -> 'a
    let while_skip2 buffer pprime testf accf acc =
        let buffer, is_prime = next_buffer buffer pprime in
        if is_prime then
            let continue = testf pprime !acc in
            if continue then
                while_skip4 buffer (pprime + 4) testf accf (accf pprime acc)
            else
                let () = Buffer.release buffer in
                acc
        else
           while_skip4 buffer (pprime + 4) testf accf acc 
    
    val private while_skip4 : t Buffer.t * int * (int * 'a obs -> bool) * (int * 'a -> 'a) * 'a -> 'a
    let while_skip4 buffer pprime testf accf acc =
        let buffer, is_prime = next_buffer buffer pprime in
        if is_prime then
            let continue = testf pprime !acc in
            if continue then
                while_skip2 buffer (pprime + 2) testf accf (accf pprime acc)
            else
                let () = Buffer.release buffer in
                acc
        else
           while_skip2 buffer (pprime + 2) testf accf acc 
    
end

